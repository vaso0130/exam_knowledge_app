import google.generativeai as genai
import asyncio
import json
import time
from typing import Dict, Any, List, Optional
from dotenv import load_dotenv
import os
from ..utils.json_parser import extract_json_from_text

class GeminiClient:
    def __init__(self, api_key: str = None):
        load_dotenv()
        self.api_key = api_key or os.getenv('GEMINI_API_KEY') or os.getenv('GOOGLE_API_KEY')
        if not self.api_key:
            raise ValueError("è«‹è¨­å®š GEMINI_API_KEY æˆ– GOOGLE_API_KEY ç’°å¢ƒè®Šæ•¸")
        
        genai.configure(api_key=self.api_key)
        self.model = genai.GenerativeModel('gemini-1.5-flash')
        
        self.generation_config = genai.types.GenerationConfig(
            temperature=0.2,
            top_p=0.9,
            max_output_tokens=8192,
            response_mime_type="application/json"
        )
    
    async def _generate_with_json_parsing(self, prompt: str) -> Optional[Dict[str, Any]]:
        raw_response = await self.generate_async(prompt)
        if not raw_response:
            return None
        
        parsed_json = extract_json_from_text(raw_response)
        return parsed_json

    async def generate_async(self, prompt: str, is_json: bool = True) -> str:
        try:
            config = self.generation_config if is_json else genai.types.GenerationConfig(
                temperature=0.3,
                top_p=0.9,
                max_output_tokens=4096
            )
            response = await asyncio.to_thread(
                self.model.generate_content,
                prompt,
                generation_config=config
            )
            return response.text
        except Exception as e:
            print(f"Gemini API éŒ¯èª¤: {e}")
            return ""

    async def parse_exam_paper(self, text: str) -> Dict[str, Any]:
        """
        è§£æè€ƒå·å…§å®¹ï¼Œè‡ªå‹•åˆ†å‰²é¡Œç›®ä¸¦è­˜åˆ¥è€ƒç§‘ï¼Œä¸¦é€²è¡Œé›£åº¦åˆ†ç´š
        """
        prompt = f"""
        è«‹åˆ†æä»¥ä¸‹æ–‡æœ¬å…§å®¹ï¼Œé€™å¯èƒ½æ˜¯ä¸€ä»½è€ƒå·æˆ–åŒ…å«å¤šå€‹é¡Œç›®çš„å­¸ç¿’è³‡æ–™ã€‚

        ä»»å‹™ï¼š
        1. è‡ªå‹•è­˜åˆ¥è€ƒç§‘é¡åˆ¥ï¼ˆå¾ï¼šè³‡æ–™çµæ§‹ã€è³‡è¨Šç®¡ç†ã€è³‡é€šç¶²è·¯èˆ‡è³‡è¨Šå®‰å…¨ã€è³‡æ–™åº«æ‡‰ç”¨ã€æˆ–å…¶ä»–ï¼‰
        2. åˆ¤æ–·å…§å®¹é¡å‹ï¼ˆexam_paper or study_materialï¼‰
        3. å¦‚æœæ˜¯è€ƒå·ï¼Œè«‹å°‡æ¯å€‹é¡Œç›®åˆ†å‰²é–‹ä¾†ï¼ˆæ³¨æ„ï¼šä¸€å€‹é¡Œç›®å¯èƒ½åŒ…å«å¤šå€‹å°å•é¡Œï¼Œé€™äº›æ‡‰è©²è¦–ç‚ºåŒä¸€é¡Œï¼‰
        4. å¦‚æœæ˜¯å­¸ç¿’è³‡æ–™ï¼Œè«‹æå–æ ¸å¿ƒçŸ¥è­˜é»
        5. **æ–°å¢**ï¼šå°æ¯å€‹è€ƒé¡Œé€²è¡Œé›£åº¦åˆ†ç´šåˆ†æ

        **é‡è¦ï¼šé¡Œç›®åˆ†å‰²åŸå‰‡**
        - ä¸€å€‹é¡Œç›®å¯èƒ½åŒ…å«å¤šå€‹éƒ¨åˆ†ï¼ˆå¦‚ï¼šå•é¡Œæè¿° + ç¨‹å¼ç¢¼ + å¤šå€‹å°å•é¡Œï¼‰
        - åªæœ‰æ˜ç¢ºçš„é¡Œè™Ÿåˆ†éš”ï¼ˆå¦‚ã€Œç¬¬ä¸€é¡Œã€ã€ã€Œ1.ã€ã€ã€Œé¡Œç›®äºŒã€ï¼‰æ‰åˆ†å‰²
        - åŒä¸€é¡Œç›®å…§çš„ä¸åŒéƒ¨åˆ†ï¼ˆå¦‚ã€Œ(10åˆ†)ã€ã€ã€Œè«‹åˆ†æã€ã€ã€Œè«‹èªªæ˜ã€ï¼‰æ‡‰åˆä½µç‚ºä¸€é¡Œ
        - ç¨‹å¼ç¢¼å’Œç›¸é—œå•é¡Œæ‡‰è©²ä¿æŒåœ¨åŒä¸€é¡Œä¸­
        - **ç¨‹å¼ç¢¼/è™›æ“¬ç¢¼æ ¼å¼**ï¼šå¦‚æœé¡Œç›®åŒ…å«ç¨‹å¼ç¢¼æˆ–è™›æ“¬ç¢¼ï¼Œè«‹å‹™å¿…ä½¿ç”¨ Markdown çš„ fenced code blocks (```) åŒ…è£¹èµ·ä¾†ï¼Œä¸¦æŒ‡å®šèªè¨€ï¼ˆå¦‚ ````python` æˆ– ````pseudocode`ï¼‰ã€‚
        - **é—œè¯é¡Œç›®è™•ç†**ï¼šå¦‚æœé¡Œç›®æåˆ°ã€Œæ‰¿ä¸Šé¡Œã€ã€ã€Œæ¥ä¸Šé¡Œã€ã€ã€Œå»¶çºŒä¸Šé¡Œã€ã€ã€Œæ ¹æ“šä¸Šé¡Œã€ã€ã€ŒåŸºæ–¼å‰é¡Œã€ç­‰å­—æ¨£ï¼Œæ‡‰å°‡ç›¸é—œè¯çš„é¡Œç›®åˆä½µç‚ºåŒä¸€é¡Œ
        - **é€£çºŒæ€§é¡Œç›®**ï¼šå¦‚æœæŸé¡Œçš„è§£ç­”éœ€è¦ä¾è³´å‰ä¸€é¡Œçš„çµæœæˆ–å…§å®¹ï¼Œæ‡‰è€ƒæ…®å°‡å®ƒå€‘è¦–ç‚ºåŒä¸€é¡Œçš„ä¸åŒéƒ¨åˆ†
        - **åˆä½µæ–¹å¼**ï¼šåˆä½µé¡Œç›®æ™‚ï¼Œä½¿ç”¨è¼ƒå‰é¢çš„é¡Œè™Ÿï¼Œæ¨™é¡Œå¯ä»¥æ¦‚æ‹¬å…©é¡Œå…§å®¹ï¼Œstem åŒ…å«å…©é¡Œçš„å®Œæ•´æ–‡å­—

        **é¡Œç›®é›£åº¦åˆ†ç´šæ¨™æº–ï¼š**

        ### ğŸŸ¢ ç°¡å–®é¡Œç›®ï¼ˆé«˜å¼•å°ï¼‰
        - **ç‰¹å¾µ**ï¼šæ˜ç¢ºæŒ‡å®šåˆ†ææ¡†æ¶æˆ–æ–¹æ³•ï¼ˆå¦‚ã€Œå¾ CIA ä¸‰è¦ç´ çš„è§’åº¦ã€ã€ã€Œé‹ç”¨ SWOT åˆ†ææ³•ã€ï¼‰
        - **é—œéµè©**ï¼šã€Œå¾...çš„è§’åº¦ã€ã€ã€Œé‹ç”¨...åˆ†æã€ã€ã€Œä¾æ“š...æ¡†æ¶ã€ã€ã€Œè«‹èªªæ˜...ã€ã€ã€Œè«‹è§£é‡‹...ã€
        - **é¡Œç›®é¡å‹**ï¼šå®šç¾©å‹ã€èªªæ˜å‹ã€æŒ‰æ¡†æ¶åˆ†æå‹

        ### ğŸŸ¡ ä¸­ç­‰é¡Œç›®ï¼ˆä¸­å¼•å°ï¼‰
        - **ç‰¹å¾µ**ï¼šæä¾›éƒ¨åˆ†å¼•å°ä½†ä¸æŒ‡å®šå…·é«”åˆ†ææ¡†æ¶
        - **é—œéµè©**ï¼šã€Œè«‹åˆ†æ...ã€ã€ã€Œè«‹æ¯”è¼ƒ...ã€ã€ã€Œè«‹è©•ä¼°...ã€ã€ã€Œè¨è«–...çš„å½±éŸ¿ã€
        - **é¡Œç›®é¡å‹**ï¼šåˆ†æå‹ã€æ¯”è¼ƒå‹ã€è©•ä¼°å‹

        ### ğŸ”´ å›°é›£é¡Œç›®ï¼ˆä½å¼•å°ï¼‰
        - **ç‰¹å¾µ**ï¼šé–‹æ”¾æ€§å•é¡Œï¼Œéœ€è¦ç¶œåˆå¤šç¨®çŸ¥è­˜å’Œå‰µæ–°æ€ç¶­
        - **é—œéµè©**ï¼šã€Œè«‹è¨­è¨ˆ...ã€ã€ã€Œåˆ¶å®šç­–ç•¥...ã€ã€ã€Œæå‡ºè§£æ±ºæ–¹æ¡ˆ...ã€ã€ã€Œç¶œåˆè«–è¿°...ã€
        - **é¡Œç›®é¡å‹**ï¼šè¨­è¨ˆå‹ã€ç­–ç•¥å‹ã€ç¶œåˆæ‡‰ç”¨å‹

        æ–‡æœ¬å…§å®¹ï¼š
        {text}

        **è™•ç†æ­¥é©Ÿï¼š**
        1. é¦–å…ˆè­˜åˆ¥æ‰€æœ‰æ˜ç¢ºçš„é¡Œè™Ÿå’Œé¡Œç›®
        2. æª¢æŸ¥æ¯å€‹é¡Œç›®æ˜¯å¦åŒ…å«é—œè¯æ€§é—œéµå­—ï¼ˆæ‰¿ä¸Šé¡Œã€æ¥ä¸Šé¡Œã€å»¶çºŒä¸Šé¡Œã€æ ¹æ“šä¸Šé¡Œã€åŸºæ–¼å‰é¡Œç­‰ï¼‰
        3. å¦‚æœç™¼ç¾é—œè¯æ€§é—œéµå­—ï¼Œå°‡è©²é¡Œèˆ‡å‰ä¸€é¡Œåˆä½µç‚ºä¸€å€‹é …ç›®
        4. å°æ¯å€‹æœ€çµ‚çš„é¡Œç›®é …ç›®é€²è¡Œé›£åº¦åˆ†ç´š

        è«‹ä»¥JSONæ ¼å¼å›æ‡‰ï¼š
        {{
            "content_type": "exam_paper" or "study_material",
            "subject": "æ¨æ¸¬çš„è€ƒç§‘åç¨±",
            "questions": [
                {{
                    "title": "é¡Œç›®çš„ç°¡çŸ­æ¨™é¡Œï¼ˆ5-10å€‹å­—ï¼‰",
                    "stem": "å®Œæ•´é¡Œç›®å…§å®¹ï¼ˆåŒ…å«æ‰€æœ‰éƒ¨åˆ†ï¼šå•é¡Œæè¿°ã€ç¨‹å¼ç¢¼ã€æ‰€æœ‰å°å•é¡Œï¼Œ**ä¸åŒ…å«ä»»ä½•è§£ææˆ–ç­”æ¡ˆ**ï¼‰",
                    "knowledge_points": ["ç›¸é—œçŸ¥è­˜é»1", "ç›¸é—œçŸ¥è­˜é»2"],
                    "difficulty": "ç°¡å–®|ä¸­ç­‰|å›°é›£",
                    "guidance_level": "é«˜|ä¸­|ä½",
                    "difficulty_reason": "åˆ†ç´šç†ç”±ï¼ˆèªªæ˜ç‚ºä»€éº¼æ˜¯é€™å€‹é›£åº¦ï¼‰"
                }}
            ]
        }}
        """
        return await self._generate_with_json_parsing(prompt) or {}

    async def generate_questions_from_text(self, text: str, subject: str) -> List[Dict[str, Any]]:
        """
        æ ¹æ“šå®Œæ•´æ–‡æœ¬å…§å®¹ç”Ÿæˆé«˜å“è³ªç”³è«–æ¨¡æ“¬é¡Œï¼Œä¸¦ç‚ºæ¯å€‹å•é¡Œè‡ªå‹•æ¨™è¨»çŸ¥è­˜é»æ¨™ç±¤
        å°ˆæ³¨æ–¼ç”Ÿæˆéœ€è¦æ·±å…¥åˆ†æå’Œæ‡‰ç”¨çš„é¡Œç›®ï¼Œè€Œéå–®ç´”è¤‡è¿°çŸ¥è­˜
        """
        prompt = f"""
        ä½ æ˜¯ä¸€ä½å°ˆæ¥­çš„{subject}ç§‘ç”³è«–é¡Œå‡ºé¡Œå°ˆå®¶ã€‚è«‹æ ¹æ“šæä¾›çš„å­¸ç¿’è³‡æ–™ï¼Œè¨­è¨ˆ2-4é“é«˜å“è³ªçš„ç”³è«–æ¨¡æ“¬é¡Œã€‚

        **æ ¸å¿ƒè¦æ±‚ï¼š**
        1. **çµ•å°ç¦æ­¢**ç”Ÿæˆã€Œè«‹èªªæ˜...ã€ã€ã€Œè«‹è§£é‡‹...ã€ã€ã€Œè«‹è©³è¿°...ã€ã€ã€Œ...æ˜¯ä»€éº¼ã€ç­‰ç›´æ¥è¤‡è¿°å‹é¡Œç›®
        2. **å¿…é ˆå‰µé€ æ‡‰ç”¨æƒ…å¢ƒ**ï¼šæ¯é“é¡Œç›®éƒ½è¦è¨­è¨ˆä¸€å€‹è™›æ§‹ä½†åˆç†çš„å¯¦å‹™æƒ…å¢ƒ
        3. **è¦æ±‚æ·±åº¦åˆ†æ**ï¼šé¡Œç›®æ‡‰è©²æ¸¬è©¦å­¸ç”Ÿçš„åˆ†æã€æ¯”è¼ƒã€è©•ä¼°ã€è¨­è¨ˆèƒ½åŠ›
        4. **å¤šå…ƒæ€è€ƒ**ï¼šé¡Œç›®æ‡‰è©²å…è¨±å¤šè§’åº¦æ€è€ƒå’Œè«–è¿°

        **é‡è¦ï¼šé¡Œç›®æ ¼å¼è¦æ±‚**
        - **é¡Œç›®å…§å®¹**ï¼šåªèƒ½åŒ…å«æƒ…å¢ƒæè¿°å’Œå•é¡Œè¦æ±‚ï¼Œçµ•å°ä¸èƒ½åŒ…å«ç­”æ¡ˆæ­¥é©Ÿã€åˆ†æéç¨‹æˆ–è§£æ±ºæ–¹æ¡ˆ
        - **é¡Œç›®é•·åº¦**ï¼šæ‡‰è©²æ§åˆ¶åœ¨100-200å­—å…§ï¼Œç°¡æ½”æ˜ç¢º
        - **å•é¡Œå°å‘**ï¼šé¡Œç›®å¿…é ˆä»¥å•å¥çµå°¾ï¼Œå¦‚ã€Œè«‹åˆ†æ...ã€ã€ã€Œè©¦è«–è¿°...ã€ã€ã€Œè«‹æå‡º...ã€

        **é¡Œç›®è¨­è¨ˆåŸå‰‡ï¼š**
        - æƒ…å¢ƒå°å‘ï¼šå‰µé€ å…·é«”çš„å…¬å¸ã€çµ„ç¹”æˆ–å€‹äººæ¡ˆä¾‹
        - å•é¡Œè§£æ±ºï¼šè¦æ±‚å­¸ç”Ÿæå‡ºè§£æ±ºæ–¹æ¡ˆæˆ–å»ºè­°
        - æ‰¹åˆ¤æ€è€ƒï¼šè¦æ±‚åˆ†æå„ªç¼ºé»ã€æ¯”è¼ƒä¸åŒæ–¹æ³•
        - å¯¦å‹™æ‡‰ç”¨ï¼šå°‡ç†è«–çŸ¥è­˜æ‡‰ç”¨åˆ°å¯¦éš›æƒ…æ³

        **å­¸ç¿’è³‡æ–™ï¼š**
        ```
        {text}
        ```

        **è«‹ä»¥JSONæ ¼å¼å›æ‡‰ï¼ŒåŒ…å«2-4é“ä¸åŒé›£åº¦çš„ç”³è«–é¡Œï¼š**
        {{
            "questions": [
                {{
                    "title": "ç°¡æ½”æ¨™é¡Œï¼ˆ5-8å€‹å­—ï¼‰",
                    "question": "ç´”ç²¹çš„é¡Œç›®å…§å®¹ï¼ˆåªåŒ…å«æƒ…å¢ƒæè¿°å’Œå•é¡Œè¦æ±‚ï¼Œä¸åŒ…å«ç­”æ¡ˆæˆ–åˆ†æéç¨‹ï¼‰",
                    "answer": "ç°¡æ½”çš„åƒè€ƒç­”æ¡ˆï¼ˆåŒ…å«æ ¸å¿ƒè¦é»ï¼‰",
                    "difficulty": "ç°¡å–®|ä¸­ç­‰|å›°é›£",
                    "knowledge_points": ["ç›¸é—œçŸ¥è­˜é»1", "ç›¸é—œçŸ¥è­˜é»2", "ç›¸é—œçŸ¥è­˜é»3"],
                    "guidance_level": "å¼•å°ç¨‹åº¦ï¼ˆé«˜|ä¸­|ä½ï¼‰"
                }}
            ]
        }}
        """
        parsed_json = await self._generate_with_json_parsing(prompt)
        return parsed_json.get("questions", []) if parsed_json else []

    async def generate_answer(self, question_text: str) -> Optional[Dict[str, Any]]:
        """
        æ ¹æ“šæä¾›çš„å•é¡Œæ–‡æœ¬ï¼Œç”Ÿæˆè©³ç´°çš„ç­”æ¡ˆã€‚

        Args:
            question_text: å•é¡Œçš„å®Œæ•´æ–‡å­—ã€‚

        Returns:
            ä¸€å€‹åŒ…å«ç­”æ¡ˆçš„å­—å…¸ï¼Œä¾‹å¦‚ï¼š{'answer': 'é€™æ˜¯è©³ç´°çš„å›ç­”...'}
        """
        prompt = f"""
        ä½ æ˜¯ä¸€ä½é ‚å°–çš„é ˜åŸŸå°ˆå®¶ï¼Œè«‹é‡å°ä»¥ä¸‹å•é¡Œï¼Œæä¾›ä¸€å€‹å°ˆæ¥­ã€æ·±å…¥ã€ä¸”çµæ§‹åŒ–çš„è©³ç›¡å›ç­”ã€‚

        **å•é¡Œï¼š**
        ```
        {question_text}
        ```

        **å›ç­”è¦æ±‚ï¼š**
        1.  **æ·±å…¥åˆ†æ**ï¼šä¸åƒ…åƒ…æ˜¯è¡¨é¢ç­”æ¡ˆï¼Œè¦æä¾›èƒŒæ™¯ã€åŸç†ã€å’Œå¤šè§’åº¦çš„è§£é‡‹ã€‚
        2.  **çµæ§‹æ¸…æ™°**ï¼šä½¿ç”¨é»åˆ—ã€æ¨™é¡Œã€æˆ–åˆ†æ®µä¾†çµ„ç¹”å…§å®¹ï¼Œä½¿å…¶æ˜“æ–¼ç†è§£ã€‚
        3.  **å°ˆæ¥­æº–ç¢º**ï¼šç¢ºä¿æ‰€æœ‰è³‡è¨Šéƒ½æ˜¯æœ€æ–°ä¸”æº–ç¢ºçš„ã€‚
        4.  **ç¨‹å¼ç¢¼/è™›æ“¬ç¢¼æ ¼å¼**ï¼šå¦‚æœç­”æ¡ˆåŒ…å«ç¨‹å¼ç¢¼æˆ–è™›æ“¬ç¢¼ï¼Œè«‹å‹™å¿…ä½¿ç”¨ Markdown çš„ fenced code blocks (```) åŒ…è£¹èµ·ä¾†ï¼Œä¸¦æŒ‡å®šèªè¨€ï¼ˆå¦‚ ````python` æˆ– ````pseudocode`ï¼‰ã€‚
        5.  **ç­”æ¡ˆå…§å®¹å¿…é ˆæ˜¯ç´”æ–‡å­—å­—ä¸²**ï¼šå³ä½¿ç­”æ¡ˆå…§å®¹åŒ…å«å¤šå€‹éƒ¨åˆ†æˆ–çµæ§‹åŒ–è³‡è¨Šï¼Œæœ€çµ‚çš„ `answer` æ¬„ä½å€¼ä¹Ÿå¿…é ˆæ˜¯ä¸€å€‹å–®ä¸€çš„ã€æ ¼å¼åŒ–å¥½çš„ Markdown å­—ä¸²ï¼Œè€Œä¸æ˜¯å·¢ç‹€çš„ JSON ç‰©ä»¶ã€‚

        **è«‹ä»¥åš´æ ¼çš„JSONæ ¼å¼å›æ‡‰ï¼š**
        ```json
        {{
            "answer": "ï¼ˆåœ¨é€™è£¡å¡«å¯«ä½ è©³ç´°ã€çµæ§‹åŒ–çš„å°ˆæ¥­å›ç­”ï¼‰"
        }}
        ```
        """
        return await self._generate_with_json_parsing(prompt)

    async def generate_summary(self, text: str) -> Dict[str, Any]:
        """
        ç”Ÿæˆæ‘˜è¦
        """
        prompt = f"""
        è«‹ç‚ºä»¥ä¸‹å…§å®¹ç”Ÿæˆçµæ§‹åŒ–çš„çŸ¥è­˜é‡é»æ‘˜è¦ã€‚è«‹ç‰¹åˆ¥æ³¨æ„ï¼š

        1. **æå–è¡¨æ ¼è³‡è¨Š**ï¼šå¦‚æœå…§å®¹åŒ…å«è¡¨æ ¼ï¼Œè«‹å°‡è¡¨æ ¼è³‡è¨Šè½‰æ›ç‚ºæ¸…æ™°çš„é‡é»é …ç›®
        2. **æŠ€è¡“è¡“èªæ•´ç†**ï¼šå°‡å°ˆæ¥­è¡“èªã€æŠ€è¡“åç¨±ã€æ”»æ“Šæ‰‹æ³•ç­‰æ•´ç†æˆå­¸ç¿’è¦é»ï¼Œ**æ¯å€‹è¡“èªéƒ½è¦æä¾›ç°¡æ½”çš„è§£é‡‹**
        3. **é¿å…é‡è¤‡**ï¼šä¸è¦ç›´æ¥è¤‡è¿°åŸæ–‡ï¼Œè€Œæ˜¯è¦æ­¸ç´å‡ºé—œéµæ¦‚å¿µå’Œè¦é»
        4. **å¯¦ç”¨æ€§å°å‘**ï¼šé‡é»æ‡‰è©²æ˜¯ä¾¿æ–¼å­¸ç¿’å’Œè¨˜æ†¶çš„çŸ¥è­˜é»

        **å…§å®¹ï¼š**
        {text[:6000]}

        è«‹ä»¥JSONæ ¼å¼å›æ‡‰ï¼Œç”Ÿæˆé«˜å“è³ªçš„å­¸ç¿’æ‘˜è¦ï¼š
        {{
            "summary": "ä¸€å¥è©±æ¦‚æ‹¬æ•´é«”å…§å®¹çš„æ ¸å¿ƒä¸»é¡Œ",
            "key_concepts": [
                {{"name": "æ ¸å¿ƒæ¦‚å¿µ1", "description": "ç°¡æ½”çš„è§£é‡‹èªªæ˜"}},
                {{"name": "æ ¸å¿ƒæ¦‚å¿µ2", "description": "ç°¡æ½”çš„è§£é‡‹èªªæ˜"}}
            ],
            "technical_terms": [
                {{"name": "æŠ€è¡“è¡“èª1", "description": "ä¸€å¥è©±è§£é‡‹é€™å€‹è¡“èªçš„å«ç¾©å’Œä½œç”¨"}},
                {{"name": "æŠ€è¡“è¡“èª2", "description": "ä¸€å¥è©±è§£é‡‹é€™å€‹è¡“èªçš„å«ç¾©å’Œä½œç”¨"}}
            ],
            "classification_info": [
                {{"name": "åˆ†é¡é …ç›®1", "description": "åˆ†é¡çš„è©³ç´°èªªæ˜æˆ–ç­‰ç´šå…§å®¹"}},
                {{"name": "åˆ†é¡é …ç›®2", "description": "åˆ†é¡çš„è©³ç´°èªªæ˜æˆ–ç­‰ç´šå…§å®¹"}}
            ],
            "practical_applications": [
                {{"name": "å¯¦å‹™æ‡‰ç”¨1", "description": "å…·é«”çš„æ‡‰ç”¨å ´æ™¯æˆ–å¯¦æ–½æ–¹æ³•"}},
                {{"name": "å¯¦å‹™æ‡‰ç”¨2", "description": "å…·é«”çš„æ‡‰ç”¨å ´æ™¯æˆ–å¯¦æ–½æ–¹æ³•"}}
            ],
            "bullets": ["æ•´åˆæ€§é‡é»1ï¼šåŒ…å«è©³ç´°èªªæ˜", "æ•´åˆæ€§é‡é»2ï¼šåŒ…å«è©³ç´°èªªæ˜", "æ•´åˆæ€§é‡é»3ï¼šåŒ…å«è©³ç´°èªªæ˜"]
        }}
        """
        parsed_json = await self._generate_with_json_parsing(prompt)
        if parsed_json and 'summary' in parsed_json and 'bullets' in parsed_json:
            return parsed_json
        return {"summary": "ç„¡æ³•ç”Ÿæˆæ‘˜è¦", "bullets": []}

    async def generate_quick_quiz(self, content: str, subject: str) -> List[Dict[str, Any]]:
        """ç”Ÿæˆå¿«é€Ÿæ¸¬é©—é¸æ“‡é¡Œ"""
        
        prompt = f"""
        ä½ æ˜¯ä¸€ä½å°ˆæ¥­çš„æ•™è‚²æ¸¬é©—è¨­è¨ˆå¸«ã€‚è«‹æ ¹æ“šä»¥ä¸‹å­¸ç¿’è³‡æ–™ï¼Œè¨­è¨ˆ5é“é¸æ“‡é¡Œä¾†å¿«é€Ÿæª¢é©—å­¸ç¿’è€…å°é‡é»çŸ¥è­˜çš„æŒæ¡ã€‚

        **è¨­è¨ˆåŸå‰‡ï¼š**
        1. é¡Œç›®æ‡‰è©²æ¸¬è©¦å°æ ¸å¿ƒæ¦‚å¿µçš„ç†è§£ï¼Œè€Œéç´°ç¯€è¨˜æ†¶
        2. é¿å…æ¶‰åŠå…·é«”çš„å…¬å¸åç¨±ã€ç”¢å“åç¨±æˆ–æ™‚äº‹æ–°è
        3. å°ˆæ³¨æ–¼çŸ¥è­˜é»æœ¬èº«çš„åŸç†ã€æ¦‚å¿µå’Œæ‡‰ç”¨
        4. æ¯é¡Œæä¾›4å€‹é¸é …ï¼Œå…¶ä¸­åªæœ‰1å€‹æ­£ç¢ºç­”æ¡ˆ
        5. æä¾›ç°¡æ½”æ˜ç¢ºçš„è§£æèªªæ˜

        **ç§‘ç›®é ˜åŸŸï¼š** {subject}

        **å­¸ç¿’è³‡æ–™ï¼š**
        {content}

        **è«‹ä»¥JSONæ ¼å¼å›æ‡‰ï¼ŒåŒ…å«5é“é¸æ“‡é¡Œï¼š**
        {{
            "quiz": [
                {{
                    "question": "é¡Œç›®å…§å®¹",
                    "type": "multiple_choice",
                    "options": ["A. é¸é …1", "B. é¸é …2", "C. é¸é …3", "D. é¸é …4"],
                    "correct_answer": "A",
                    "explanation": "è§£æèªªæ˜"
                }}
            ]
        }}
        """
        
        try:
            parsed_response = await self._generate_with_json_parsing(prompt)
            if parsed_response and 'quiz' in parsed_response:
                return parsed_response['quiz']
            else:
                print("è­¦å‘Šï¼šç„¡æ³•è§£æå¿«é€Ÿæ¸¬é©—JSONå›æ‡‰")
                return []
        except Exception as e:
            print(f"ç”Ÿæˆå¿«é€Ÿæ¸¬é©—éŒ¯èª¤: {e}")
            return []

    async def generate_mindmap(self, subject: str, knowledge_points: List[str]) -> str:
        """
        æ ¹æ“šè¼¸å…¥çš„æ–‡æœ¬ï¼Œç”Ÿæˆ Mermaid.js æ ¼å¼çš„å¿ƒæ™ºåœ– Markdownã€‚
        """
        # å°‡çŸ¥è­˜é»åˆ—è¡¨è½‰æ›ç‚º Mermaid ç¯€é»
        nodes_text = ""
        for kp in knowledge_points:
            # ç¢ºä¿ kp æ˜¯å­—ä¸²é¡å‹ï¼Œé˜²æ­¢ 'dict' object has no attribute 'replace' éŒ¯èª¤
            if isinstance(kp, dict):
                # å¦‚æœæ˜¯å­—å…¸ï¼Œå˜—è©¦æå–æœ‰æ„ç¾©çš„å­—ä¸²å€¼
                kp_str = kp.get('name', '') or kp.get('title', '') or kp.get('text', '') or str(kp)
            elif kp is None:
                continue  # è·³é None å€¼
            else:
                kp_str = str(kp)  # ç¢ºä¿æ˜¯å­—ä¸²
            
            # ç¢ºä¿çŸ¥è­˜é»ä¸å«ç ´å£æ ¼å¼çš„å­—å…ƒï¼Œä¸¦åŠ ä¸Šå¼•è™Ÿ
            safe_kp = kp_str.replace('\\', '\\\\').replace('"', '\"').replace('\n', ' ').replace('\r', '')
            nodes_text += f"""      "{safe_kp}"\n"""

        # æº–å‚™çŸ¥è­˜é»å­—ä¸²åˆ—è¡¨ç”¨æ–¼é¡¯ç¤º
        safe_knowledge_points = []
        for kp in knowledge_points:
            if isinstance(kp, dict):
                kp_str = kp.get('name', '') or kp.get('title', '') or kp.get('text', '') or str(kp)
            elif kp is None:
                continue
            else:
                kp_str = str(kp)
            safe_knowledge_points.append(kp_str)

        prompt = f"""
        è«‹æ ¹æ“šä»¥ä¸‹æ ¸å¿ƒä¸»é¡Œå’Œé—œéµçŸ¥è­˜é»ï¼Œç”Ÿæˆä¸€å€‹ Mermaid.js æ ¼å¼çš„å¿ƒæ™ºåœ–ã€‚
        å¿ƒæ™ºåœ–æ‡‰è©²ä»¥æ ¸å¿ƒä¸»é¡Œç‚ºæ ¹ç¯€é»ï¼Œä¸¦å°‡æ¯å€‹çŸ¥è­˜é»ä½œç‚ºå…¶ä¸»è¦åˆ†æ”¯ã€‚
        è«‹ç¢ºä¿è¼¸å‡ºçš„æ ¼å¼æ˜¯ç´”ç²¹çš„ Mermaid Markdownï¼Œä»¥ `mindmap` é–‹é ­ã€‚
        é‡è¦ï¼šç¯€é»çš„æ–‡å­—å·²ç”¨é›™å¼•è™ŸåŒ…èµ·ä¾†ï¼Œè«‹ç›´æ¥ä½¿ç”¨ã€‚

        æ ¸å¿ƒä¸»é¡Œï¼š{subject}
        
        çŸ¥è­˜é»ï¼š
{', '.join(safe_knowledge_points)}

        Mermaid å¿ƒæ™ºåœ–ç¯„ä¾‹æ ¼å¼ï¼š
        mindmap
          root(("{subject}"))
{nodes_text}
        
        è«‹ç›´æ¥è¼¸å‡º Mermaid ä»£ç¢¼ï¼Œä¸è¦åŒ…å«ä»»ä½•é¡å¤–çš„è§£é‡‹æˆ– ```mermaid ... ``` æ¨™è¨˜ã€‚
        """
        # å°æ–¼å¿ƒæ™ºåœ–ï¼Œæˆ‘å€‘æœŸæœ›ç´”æ–‡å­—è¼¸å‡ºï¼Œè€Œä¸æ˜¯ JSON
        try:
            # å»ºç«‹ä¸€å€‹ä¸è¦æ±‚ JSON çš„ç”Ÿæˆè¨­å®š
            text_generation_config = genai.types.GenerationConfig(
                temperature=0.3,
                top_p=0.9,
                max_output_tokens=2048,
            )
            response = await asyncio.to_thread(
                self.model.generate_content,
                prompt,
                generation_config=text_generation_config
            )
            # æ¸…ç†å›æ‡‰ï¼Œç¢ºä¿æ˜¯åˆæ³•çš„ Mermaid ä»£ç¢¼
            mermaid_code = response.text.strip()
            if not mermaid_code.startswith("mindmap"):
                return "mindmap\n  root((ç”Ÿæˆå¤±æ•—))\n    è«‹æª¢æŸ¥è¼¸å…¥å…§å®¹æˆ– API é€£ç·š"
            return mermaid_code
        except Exception as e:
            print(f"ç”Ÿæˆå¿ƒæ™ºåœ–æ™‚ç™¼ç”ŸéŒ¯èª¤: {e}")
            return "mindmap\n  root((éŒ¯èª¤))\n    ç„¡æ³•ç”Ÿæˆå¿ƒæ™ºåœ–"

    async def extract_knowledge_points(self, text: str, subject: str) -> Optional[List[str]]:
        """å¾æ–‡æœ¬ä¸­æå–çŸ¥è­˜é»"""
        prompt = f"""
        ä½ æ˜¯ä¸€ä½å°ˆæ¥­çš„{subject}ç§‘è€å¸«ï¼Œä½ çš„ä»»å‹™æ˜¯å¾çµ¦å®šçš„è€ƒè©¦é¡Œç›®æˆ–æ–‡æœ¬ä¸­ï¼Œç²¾æº–åœ°æå–å‡ºæ ¸å¿ƒçš„ã€ŒçŸ¥è­˜é»ã€ã€‚

        **ä»»å‹™èªªæ˜ï¼š**
        1.  **åˆ†ææ–‡æœ¬**ï¼šä»”ç´°é–±è®€ä»¥ä¸‹å…§å®¹ã€‚
        2.  **æå–çŸ¥è­˜é»**ï¼šè­˜åˆ¥å‡ºæ–‡æœ¬æ‰€æ¸¬é©—çš„2åˆ°5å€‹æœ€é‡è¦ã€æœ€æ ¸å¿ƒçš„è§€å¿µæˆ–è¡“èªã€‚çŸ¥è­˜é»æ‡‰è©²æ˜¯ç°¡æ½”ã€å…·é«”çš„åè©æˆ–çŸ­èªã€‚
        3.  **æ ¼å¼åŒ–è¼¸å‡º**ï¼šå°‡æå–çš„çŸ¥è­˜é»ä»¥JSONæ ¼å¼è¼¸å‡ºã€‚

        **æ–‡æœ¬å…§å®¹ï¼š**
        ```
        {text}
        ```

        **è¼¸å‡ºè¦æ±‚ï¼š**
        -   å¿…é ˆæ˜¯åš´æ ¼çš„JSONæ ¼å¼ã€‚
        -   JSONç‰©ä»¶æ‡‰åŒ…å«ä¸€å€‹éµ `knowledge_points`ã€‚
        -   `knowledge_points` çš„å€¼æ‡‰è©²æ˜¯ä¸€å€‹å­—ä¸²åˆ—è¡¨ï¼Œæ¯å€‹å­—ä¸²å°±æ˜¯ä¸€å€‹çŸ¥è­˜é»ã€‚

        **ç¯„ä¾‹ï¼š**
        -   **è¼¸å…¥æ–‡æœ¬ï¼ˆå…¬æ°‘èˆ‡ç¤¾æœƒï¼‰**ï¼šã€Œæ ¹æ“šæˆ‘åœ‹ã€Šå…¬å¸æ³•ã€‹è¦å®šï¼Œè‚¡æ±æœƒæ˜¯å…¬å¸çš„æœ€é«˜æ¬ŠåŠ›æ©Ÿæ§‹ã€‚è«‹å•ï¼Œè‹¥Aå…¬å¸æ±ºå®šé€²è¡Œåˆä½µï¼Œæ‡‰ç”±å“ªå€‹æ©Ÿæ§‹æ±ºè­°ï¼Ÿã€
        -   **è¼¸å‡ºJSON**ï¼š
            ```json
            {{
                "knowledge_points": [
                    "å…¬å¸æ³•",
                    "è‚¡æ±æœƒè·æ¬Š",
                    "å…¬å¸åˆä½µ"
                ]
            }}
            ```
        -   **è¼¸å…¥æ–‡æœ¬ï¼ˆç‰©ç†ï¼‰**ï¼šã€Œä¸€å€‹è³ªé‡ç‚º2å…¬æ–¤çš„ç‰©é«”ï¼Œåœ¨å…‰æ»‘æ°´å¹³é¢ä¸Šå—åˆ°10ç‰›é “çš„æ°´å¹³åŠ›ä½œç”¨ï¼Œè«‹å•å…¶åŠ é€Ÿåº¦ç‚ºä½•ï¼Ÿã€
        -   **è¼¸å‡ºJSON**ï¼š
            ```json
            {{
                "knowledge_points": [
                    "ç‰›é “ç¬¬äºŒé‹å‹•å®šå¾‹",
                    "F=ma",
                    "åŠ é€Ÿåº¦è¨ˆç®—"
                ]
            }}
            ```

        è«‹ç¾åœ¨åˆ†æçµ¦å®šçš„æ–‡æœ¬ä¸¦è¿”å›JSONçµæœã€‚
        """
        
        parsed_json = await self._generate_with_json_parsing(prompt)
        if parsed_json and 'knowledge_points' in parsed_json and isinstance(parsed_json['knowledge_points'], list):
            return parsed_json['knowledge_points']
        
        print(f"ç„¡æ³•å¾å›æ‡‰ä¸­è§£æå‡ºçŸ¥è­˜é»: {parsed_json}")
        return None

    async def generate_tags(self, text: str, subject: str) -> List[str]:
        """ç”Ÿæˆæ¨™ç±¤"""
        prompt = f"""
        åŸºæ–¼ä»¥ä¸‹ã€Œ{subject}ã€é ˜åŸŸçš„å…§å®¹ï¼Œè«‹ç”Ÿæˆ3-6å€‹ç²¾ç¢ºä¸”æœ‰ä»£è¡¨æ€§çš„æ¨™ç±¤é—œéµå­—ã€‚
        æ¨™ç±¤æ‡‰è©²æ˜¯å¸¸è¦‹çš„æŠ€è¡“è¡“èªã€æ¦‚å¿µæˆ–æ¨™æº–ã€‚

        å…§å®¹ï¼š
        {text[:2000]}

        è«‹ä»¥JSONæ ¼å¼å›æ‡‰ï¼š
        {{
            "tags": ["æ¨™ç±¤1", "æ¨™ç±¤2", "æ¨™ç±¤3", ...]
        }}
        """
        parsed_json = await self._generate_with_json_parsing(prompt)
        if parsed_json and 'tags' in parsed_json:
            return parsed_json.get("tags", [])
        return []